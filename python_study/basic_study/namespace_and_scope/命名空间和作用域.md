[第22天：Python NameSpace & Scope](https://mp.weixin.qq.com/s?__biz=MzkxNDI3NjcwMw==&mid=2247493326&idx=1&sn=07a7a05c917cafcea3a86649082d94a5&chksm=c1724efef605c7e82a26cc93c056ed1dbe3447d4a47cc00c39d94b09943ba06a2be0d0607a63&scene=21#wechat_redirect)


# 命名空间



# 2. 作用域

作用域就是一个 Python 程序可以直接访问命名空间的正文区域。

* Python 程序中，直接访问一个变量，会从内到外依次访问所有的作用域直到找到，否则会报未定义的错误。
* Python 中，程序的变量并不是在哪个位置都可以访问的，访问权限决定于这个变量是在哪里赋值的。
* Python 中， 变量的作用域决定了在哪一部分程序可以访问哪个特定的变量名称


作用域分为4类，分别如下：

* L（Local）：最内层，包含局部变量，比如一个函数/方法内部。
* E（Enclosing）：包含了非局部(non-local)也非全局(non-global)的变量。比如两个嵌套函数，一个函数（或类） A 里面又包含了一个函数 B ，那么对于 B 中的名称来说 A 中的作用域就为 nonlocal。
* G（Global）：当前脚本的最外层，比如当前模块的全局变量。
* B（Built-in）：包含了内建的变量/关键字等，最后被搜索。

作用域规则顺序为：L->E->G->B 如果变量在局部内找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再找不到就去内置中找，如下图所示：

![图片](https://mmbiz.qpic.cn/mmbiz_png/SAy0yVjKWywLj9rNGMIPfic4ajibUJCmtMFSpiazEkHF2Q90tB8hwC8ckTaWJibjkvjUo5WANaibH6W7LWJGm84d6cA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



### 6、global 和 nonlocal关键字

当内部作用域想修改外部作用域的变量时，就要用到global和nonlocal关键字了。

**变量访问顺序**：
当前作用域局部变量->外层作用域变量->再外层作用域变量->......->当前模块全局变量->pyhton内置变量

* global:全局变量,当局部作用域改变全局变量用global，同时global还可以定义新的全局变量
* nonlocal:外层嵌套函数的变量,nonlocal不能定义新的外层函数变量，只能改变已有的外层函数变量,同时nonlocal不能改变全局变量



---
### Python 作用域详解

在 Python 中，变量的作用域决定了其在代码中的可见性和生命周期。Python 的作用域遵循 **LEGB 规则**（Local → Enclosing → Global → Built-in），同时通过 `global` 和 `nonlocal` 关键字支持跨作用域变量操作。以下是详细解析：
---
### 一、作用域层级

#### 1. **Local（局部作用域）**

- **定义**：在函数内部定义的变量，仅在函数内部可见。
- **示例**：
  ```python
  def func():
      x = 10  # 局部变量
      print(x)  # 输出 10

  func()
  print(x)  # 报错：NameError: name 'x' is not defined
  ```

#### 2. **Enclosing（嵌套作用域）**

- **定义**：外层函数（非全局）的作用域，常见于闭包场景。
- **示例**：
  ```python
  def outer():
      y = 20  # Enclosing 作用域的变量
      def inner():
          print(y)  # 可访问外层函数的变量
      inner()

  outer()  # 输出 20
  ```

#### 3. **Global（全局作用域）**

- **定义**：在模块（文件）顶层定义的变量，全局可见。
- **示例**：
  ```python
  z = 30  # 全局变量

  def show_global():
      print(z)  # 访问全局变量

  show_global()  # 输出 30
  ```

#### 4. **Built-in（内置作用域）**

- **定义**：Python 内置的变量（如 `print`, `len`, `Exception` 等）。
- **示例**：
  ```python
  def use_builtin():
      print(len([1, 2, 3]))  # 访问内置函数 len

  use_builtin()  # 输出 3
  ```

---

### 二、作用域的关键字

#### 1. `global`：修改全局变量

- **用途**：在函数内部修改全局变量。
- **示例**：
  ```python
  count = 0

  def increment():
      global count  # 声明使用全局变量
      count += 1

  increment()
  print(count)  # 输出 1
  ```

#### 2. `nonlocal`：修改嵌套作用域的变量

- **用途**：在嵌套函数中修改外层函数的变量（非全局）。
- **示例**：
  ```python
  def outer():
      num = 5
      def inner():
          nonlocal num  # 声明修改外层函数的变量
          num = 10
      inner()
      print(num)  # 输出 10

  outer()
  ```

---

### 三、作用域的特殊行为

#### 1. **没有块级作用域**

Python 中只有模块（module），类（class）以及函数（def、lambda）才会引入新的作用域，其它的代码块（如 if/elif/else/、try/except、for/while等）是不会引入新的作用域的，也就是说这些语句内定义的变量，外部也可以访问

- Python 的 `if`、`for`、`while` 等代码块不会创建新的作用域。
- **示例**：
  ```python
  if True:
      var = "Python"  # 变量在 if 块外仍可见
  print(var)  # 输出 "Python"

  for i in range(3):
      pass
  print(i)  # 输出 2（i 在循环外仍存在）
  ```

#### 2. **闭包与延迟绑定**

- 闭包中引用的外层变量是“动态查找”的，可能导致意外结果。
- **经典陷阱示例**：

  ```python
  functions = []
  for i in range(3):
      def func():
          print(i)
      functions.append(func)

  # 所有函数输出 2，因为闭包引用的是循环结束后的最终值 i=2
  for f in functions:
      f()  # 输出 2, 2, 2
  ```
- **解决方法**：通过默认参数捕获当前值。

  ```python
  functions = []
  for i in range(3):
      def func(i=i):  # 通过默认参数立即绑定当前 i 的值
          print(i)
      functions.append(func)

  for f in functions:
      f()  # 输出 0, 1, 2
  ```

---

### 四、作用域与命名空间

#### 1. **查看当前作用域的变量**

- `locals()`：返回局部作用域的变量字典。
- `globals()`：返回全局作用域的变量字典。
- **示例**：
  ```python
  x = "global"

  def check_scopes():
      y = "local"
      print("局部变量:", locals())  # {'y': 'local'}
      print("全局变量:", globals().get('x'))  # "global"

  check_scopes()
  ```

#### 2. **作用域查找顺序**

- Python 按 **LEGB 顺序**查找变量：
  ```python
  name = "global"

  def outer():
      name = "enclosing"
      def inner():
          name = "local"
          print(name)  # 输出 "local"（优先局部作用域）
      inner()

  outer()
  ```

---

### 五、常见错误与解决方案

#### 1. **`UnboundLocalError`**

- **原因**：在函数内部未声明 `global` 却尝试修改全局变量。
- **示例**：

  ```python
  total = 0

  def add():
      total += 1  # 报错：UnboundLocalError

  add()
  ```
- **解决**：使用 `global` 声明：

  ```python
  def add():
      global total
      total += 1  # 正确
  ```

#### 2. **闭包中意外修改外层变量**

- **原因**：未正确使用 `nonlocal`。
- **示例**：

  ```python
  def counter():
      count = 0
      def increment():
          count += 1  # 报错：UnboundLocalError
          return count
      return increment

  c = counter()  # 调用 c() 会报错
  ```
- **解决**：使用 `nonlocal` 声明：

  ```python
  def counter():
      count = 0
      def increment():
          nonlocal count
          count += 1  # 正确
          return count
      return increment
  ```

---

### 六、总结


| 作用域类型    | 定义位置        | 访问方式            | 修改方式        |
| ------------- | --------------- | ------------------- | --------------- |
| **Local**     | 函数内部        | 直接访问            | 直接赋值        |
| **Enclosing** | 外层函数        | 直接访问            | `nonlocal` 声明 |
| **Global**    | 模块顶层        | 直接访问            | `global` 声明   |
| **Built-in**  | Python 内置模块 | 直接访问（如`len`） | 不可修改        |

理解作用域规则能帮助你：

- 避免变量命名冲突。
- 正确使用闭包和装饰器。
- 优化内存管理（局部变量随函数调用结束释放）。
