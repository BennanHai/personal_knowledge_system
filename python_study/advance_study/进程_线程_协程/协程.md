# Python 协程详解：从基础到高级

## 1. 协程（Coroutine）简介

协程（Coroutine）是 Python 中用于异步编程的一种特殊函数，它可以在函数执行过程中暂停，并在适当的时候恢复执行。与线程和进程不同，协程是用户态轻量级线程，由事件循环调度，避免了线程切换的开销。

Python 从 3.5 版本开始引入了 `async` 和 `await` 关键字，使得协程编程变得更加简洁和直观。`asyncio` 库提供了完整的事件循环和异步 I/O 支持。

asyncio 是 Python 标准库中的一个模块，用于编写异步 I/O 操作的代码。

asyncio 提供了一种高效的方式来处理并发任务，特别适用于 I/O 密集型操作，如网络请求、文件读写等。

## 2. 基本概念

### 2.1 协程 vs 线程 vs 进程

| 特性 | 协程 | 线程 | 进程 |
|------|------|------|------|
| 创建开销 | 极小 | 较小 | 大 |
| 切换开销 | 极小 | 中等 | 大 |
| 内存占用 | 极小 | 较小 | 大 |
| 并行性 | 单线程并发 | 多核并行 | 多核并行 |
| 数据共享 | 共享内存 | 共享内存 | IPC 通信 |
| 适用场景 | I/O 密集型 | I/O 密集型/计算密集型 | 计算密集型 |

### 2.2 协程的优势

1. **高效利用 I/O 等待时间**：在等待 I/O 操作时，协程可以切换到其他任务
2. **单线程并发**：避免多线程的竞争条件和锁的开销
3. **代码结构清晰**：使用 `async/await` 语法，代码更易读和维护
4. **轻量级**：可以创建成千上万个协程而不会导致系统资源耗尽

### 2.3 asyncio 库常用命令

`asyncio` 是 Python 的标准异步 I/O 库，提供了完整的异步编程框架。以下是常用的 asyncio 命令和函数：

| 命令/函数 | 用途 | 示例 |
|-----------|------|------|
| `asyncio.run()` | 运行协程，创建并管理事件循环（Python 3.7+） | `asyncio.run(main())` |
| `asyncio.create_task()` | 创建任务，调度协程并发执行 | `task = asyncio.create_task(coro())` |
| `asyncio.gather()` | 并发运行多个协程，等待所有完成 | `results = await asyncio.gather(task1, task2)` |
| `asyncio.wait()` | 等待多个协程，可设置超时和返回条件 | `done, pending = await asyncio.wait(tasks)` |
| `asyncio.sleep()` | 异步休眠，模拟 I/O 等待 | `await asyncio.sleep(1)` |
| `asyncio.get_event_loop()` | 获取当前事件循环 | `loop = asyncio.get_event_loop()` |
| `asyncio.ensure_future()` | 确保对象是 Future/Task（兼容旧版本） | `task = asyncio.ensure_future(coro())` |
| `asyncio.shield()` | 保护协程不被取消 | `await asyncio.shield(coro)` |
| `asyncio.wait_for()` | 设置协程执行超时 | `result = await asyncio.wait_for(coro, timeout=5)` |
| `asyncio.as_completed()` | 按完成顺序迭代协程 | `for fut in asyncio.as_completed(tasks):` |
| `asyncio.Queue()` | 异步队列，用于协程间通信 | `queue = asyncio.Queue(maxsize=10)` |
| `asyncio.Lock()` | 异步锁，用于同步访问共享资源 | `lock = asyncio.Lock()` |
| `asyncio.Semaphore()` | 信号量，限制并发数 | `sem = asyncio.Semaphore(5)` |
| `asyncio.Event()` | 事件对象，用于协程间通知 | `event = asyncio.Event()` |
| `asyncio.run_coroutine_threadsafe()` | 从其他线程安全地运行协程 | `future = asyncio.run_coroutine_threadsafe(coro, loop)` |

#### 常用模式示例

```python
import asyncio

# 1. 基本运行模式
async def main():
    print("Start")
    await asyncio.sleep(1)
    print("End")

asyncio.run(main())

# 2. 创建并发任务
async def concurrent_tasks():
    task1 = asyncio.create_task(worker("A", 2))
    task2 = asyncio.create_task(worker("B", 1))
    
    # 等待两个任务完成
    results = await asyncio.gather(task1, task2)
    print(f"Results: {results}")

# 3. 使用队列进行协程间通信
async def producer_consumer():
    queue = asyncio.Queue(maxsize=5)
    
    # 创建生产者和消费者
    producer_task = asyncio.create_task(producer(queue))
    consumer_task = asyncio.create_task(consumer(queue))
    
    await asyncio.gather(producer_task, consumer_task)
```

## 3. async/await 语法

### 3.1 定义协程函数

使用 `async def` 关键字定义协程函数：

```python
import asyncio

async def hello():
    print("Hello")
    await asyncio.sleep(1)  # 模拟 I/O 操作
    print("World")

# 运行协程
asyncio.run(hello())
```

### 3.2 await 表达式

`await` 关键字用于挂起协程，直到等待的异步操作完成：

```python
async def fetch_data():
    # 模拟网络请求
    await asyncio.sleep(2)
    return {"data": "example"}

async def process():
    result = await fetch_data()  # 等待 fetch_data 完成
    print(f"Received: {result}")
```

### 3.3 协程的三种状态

1. **挂起（Suspended）**：协程等待某个条件满足
2. **运行（Running）**：协程正在执行
3. **完成（Done）**：协程执行完毕或抛出异常

### 3.4 await关键字详解

`await` 是 Python 异步编程的核心关键字，用于暂停当前协程的执行，直到等待的异步操作完成，并获取其结果。

#### 3.4.1 await 的作用机制

1. **挂起协程**：当执行到 `await` 表达式时，当前协程会立即挂起，控制权交还给事件循环
2. **等待结果**：事件循环会调度其他就绪的协程执行，同时监控被等待的异步操作
3. **恢复执行**：当被等待的操作完成后，事件循环会恢复挂起的协程，并将操作结果返回给 `await` 表达式
4. **继续执行**：协程从挂起点继续执行后续代码

```python
import asyncio

async def example():
    print("Start")
    result = await asyncio.sleep(1, "result")  # 挂起点
    print(f"Resumed with: {result}")  # 恢复点
    return "done"
```

#### 3.4.2 await 的语法要求

1. **只能在协程函数中使用**：`await` 必须用在 `async def` 定义的函数内部
2. **只能等待可等待对象**：`await` 后面必须跟一个"可等待对象"（Awaitable）
3. **可等待对象的类型**：
   - **协程对象**：由协程函数调用返回
   - **任务（Task）**：`asyncio.create_task()` 创建
   - **Future 对象**：`asyncio.Future` 实例
   - **实现了 `__await__()` 方法的对象**

```python
# 正确用法
async def correct_usage():
    # 等待协程
    result1 = await coroutine_function()
    
    # 等待任务
    task = asyncio.create_task(coroutine_function())
    result2 = await task
    
    # 等待 Future
    future = asyncio.Future()
    asyncio.create_task(set_future(future))
    result3 = await future
    
    # 等待实现了 __await__ 的对象
    class AwaitableClass:
        def __await__(self):
            yield
            return "custom"
    
    result4 = await AwaitableClass()
    
    return [result1, result2, result3, result4]

# 错误用法（会引发 SyntaxError）
def sync_function():
    # await asyncio.sleep(1)  # 错误：不在协程函数中
    pass
```

#### 3.4.3 await 的高级语法

##### 3.4.3.1 链式 await

`await` 表达式可以嵌套使用，形成链式调用：

```python
async def fetch_user():
    # 模拟异步操作链
    user_id = await get_user_id()
    user_info = await get_user_info(user_id)
    user_profile = await get_user_profile(user_info["profile_id"])
    return user_profile

async def get_user_id():
    await asyncio.sleep(0.1)
    return 123

async def get_user_info(user_id):
    await asyncio.sleep(0.2)
    return {"name": "Alice", "profile_id": 456}

async def get_user_profile(profile_id):
    await asyncio.sleep(0.3)
    return {"age": 25, "city": "Beijing"}
```

##### 3.4.3.2 await 与表达式结合

`await` 可以与其他表达式组合使用：

```python
async def complex_expressions():
    # await 在条件表达式中
    condition = await check_condition()
    if condition:
        result = await process_data()
    else:
        result = await get_default()
    
    # await 在列表推导式中（Python 3.6+）
    urls = ["url1", "url2", "url3"]
    responses = [await fetch(url) for url in urls]  # 注意：这是顺序执行！
    
    # await 在三元表达式中
    value = await (get_value_a() if condition else get_value_b())
    
    # await 与赋值表达式（Python 3.8+）
    if (data := await load_data()) is not None:
        await process(data)
    
    return responses
```

##### 3.4.3.3 await 与异步上下文管理器

`await` 可以与异步上下文管理器的 `__aenter__` 和 `__aexit__` 方法一起使用：

```python
import asyncio

class AsyncResource:
    async def __aenter__(self):
        print("Acquiring resource")
        await asyncio.sleep(0.1)
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        print("Releasing resource")
        await asyncio.sleep(0.1)
    
    async def operation(self):
        await asyncio.sleep(0.5)
        return "operation result"

async def use_async_context():
    async with AsyncResource() as resource:
        result = await resource.operation()
        return result
```

##### 3.4.3.4 await 与异步迭代器

`await` 可以在异步迭代器中使用：

```python
class AsyncDataStream:
    def __init__(self, limit):
        self.limit = limit
        self.current = 0
    
    def __aiter__(self):
        return self
    
    async def __anext__(self):
        if self.current >= self.limit:
            raise StopAsyncIteration
        await asyncio.sleep(0.1)  # 模拟异步数据获取
        self.current += 1
        return f"data-{self.current}"

async def iterate_async_data():
    stream = AsyncDataStream(5)
    async for data in stream:  # 隐式使用 await
        print(f"Received: {data}")
    
    # 显式使用 await 获取下一个元素
    stream2 = AsyncDataStream(3)
    it = aiter(stream2)
    try:
        while True:
            data = await anext(it)  # 显式 await
            print(f"Manual: {data}")
    except StopAsyncIteration:
        pass
```

#### 3.4.4 await 的注意事项

##### 3.4.4.1 避免在非协程函数中使用

```python
# 错误：SyntaxError
def sync_func():
    await async_func()  # 语法错误！

# 正确：使用 asyncio.run() 包装
def sync_wrapper():
    asyncio.run(async_func())
```

##### 3.4.4.2 避免不必要的顺序等待

```python
# 低效：顺序等待
async def inefficient():
    result1 = await task1()  # 等待 task1 完成
    result2 = await task2()  # 等待 task2 完成（在 task1 完成后）
    # 总时间 = task1时间 + task2时间

# 高效：并发等待
async def efficient():
    task1_obj = asyncio.create_task(task1())
    task2_obj = asyncio.create_task(task2())
    result1 = await task1_obj  # 可能已经完成
    result2 = await task2_obj  # 可能已经完成
    # 总时间 ≈ max(task1时间, task2时间)
```

##### 3.4.4.3 处理 await 超时

```python
async def with_timeout():
    try:
        # 设置超时限制
        result = await asyncio.wait_for(
            long_running_operation(),
            timeout=2.0
        )
        return result
    except asyncio.TimeoutError:
        print("Operation timed out")
        return None

async def long_running_operation():
    await asyncio.sleep(5)  # 模拟长时间操作
    return "result"
```

##### 3.4.4.4 避免阻塞事件循环

```python
import asyncio
import time

# 错误：在协程中使用阻塞操作
async def bad_example():
    await asyncio.sleep(0.1)
    time.sleep(5)  # 阻塞事件循环5秒！
    await asyncio.sleep(0.1)

# 正确：将阻塞操作移到线程池
async def good_example():
    await asyncio.sleep(0.1)
    
    # 在线程池中执行阻塞操作
    loop = asyncio.get_running_loop()
    await loop.run_in_executor(None, time.sleep, 5)
    
    await asyncio.sleep(0.1)
```

##### 3.4.4.5 注意异常传播

```python
async def nested_await():
    try:
        # 内部协程的异常会传播到外层
        result = await failing_coroutine()
    except ValueError as e:
        print(f"Caught error from awaited coroutine: {e}")
        # 处理异常或重新抛出

async def failing_coroutine():
    await asyncio.sleep(0.1)
    raise ValueError("Something went wrong")
```

##### 3.4.4.6 await 与垃圾回收

```python
async def memory_management():
    # 创建但未等待的任务可能导致内存泄漏
    task = asyncio.create_task(long_running_task())
    
    # 如果不再需要，应该取消任务
    await asyncio.sleep(0.5)
    if some_condition:
        task.cancel()
        try:
            await task  # 等待取消完成
        except asyncio.CancelledError:
            print("Task was cancelled")
    
    # 或者确保任务最终被等待
    tasks = []
    for i in range(10):
        tasks.append(asyncio.create_task(worker(i)))
    
    # 确保所有任务完成
    await asyncio.gather(*tasks, return_exceptions=True)
```

##### 3.4.4.7 await 的性能考虑

1. **上下文切换开销**：每次 `await` 都有少量的上下文切换开销
2. **避免过度细分**：不要将操作过度细分为太多小的 `await` 点
3. **批量操作**：尽可能批量处理异步操作

```python
# 低效：多次小 await
async def many_small_awaits():
    results = []
    for i in range(100):
        results.append(await small_operation(i))  # 100次上下文切换
    return results

# 高效：批量 await
async def batch_awaits():
    tasks = [small_operation(i) for i in range(100)]
    results = await asyncio.gather(*tasks)  # 1次等待，100个并发操作
    return results

async def small_operation(i):
    await asyncio.sleep(0.01)
    return i * 2
```

#### 3.4.5 await 的常见模式

##### 3.4.5.1 重试模式

```python
import asyncio
from typing import Type

async def retry_with_backoff(
    coro_func,
    max_retries: int = 3,
    base_delay: float = 1.0,
    exceptions: tuple = (Exception,)
):
    for attempt in range(max_retries + 1):
        try:
            return await coro_func()
        except exceptions as e:
            if attempt == max_retries:
                raise
            delay = base_delay * (2 ** attempt)  # 指数退避
            print(f"Attempt {attempt + 1} failed: {e}. Retrying in {delay}s")
            await asyncio.sleep(delay)

async def unstable_operation():
    # 模拟可能失败的操作
    await asyncio.sleep(0.1)
    if random.random() < 0.5:
        raise ConnectionError("Network issue")
    return "success"
```

##### 3.4.5.2 超时与取消组合

```python
async def with_timeout_and_cancel():
    task = asyncio.create_task(long_operation())
    
    try:
        # 设置超时
        result = await asyncio.wait_for(task, timeout=3.0)
        return result
    except asyncio.TimeoutError:
        print("Timeout occurred, cancelling task")
        task.cancel()
        try:
            await task  # 等待取消完成
        except asyncio.CancelledError:
            print("Task cancelled successfully")
        raise
```

##### 3.4.5.3 条件等待

```python
async def wait_for_condition(condition_func, timeout=10.0, check_interval=0.1):
    """等待条件成立"""
    loop = asyncio.get_running_loop()
    start_time = loop.time()
    
    while True:
        if await condition_func():
            return True
        
        elapsed = loop.time() - start_time
        if elapsed >= timeout:
            raise TimeoutError(f"Condition not met after {timeout}s")
        
        await asyncio.sleep(check_interval)

async def check_database_ready():
    # 模拟检查数据库是否就绪
    await asyncio.sleep(0.5)
    return random.random() > 0.3
```

##### 3.4.5.4 异步队列消费者

```python
async def queue_consumer(queue: asyncio.Queue, stop_signal):
    """从队列消费项目直到收到停止信号"""
    while True:
        try:
            # 等待队列项目或停止信号
            item = await asyncio.wait_for(
                queue.get(),
                timeout=0.1  # 短暂超时以检查停止信号
            )
            
            # 处理项目
            await process_item(item)
            queue.task_done()
            
        except asyncio.TimeoutError:
            # 检查是否应该停止
            if stop_signal.is_set():
                print("Stop signal received, exiting")
                break
        
        except Exception as e:
            print(f"Error processing item: {e}")
            queue.task_done()
```

## 4. 事件循环（Event Loop）

事件循环是 asyncio 的核心，负责调度和执行协程。

### 4.1 获取和运行事件循环

```python
import asyncio

# 方式1：使用 asyncio.run()（Python 3.7+）
async def main():
    await asyncio.sleep(1)
    print("Done")

asyncio.run(main())

# 方式2：手动管理事件循环
loop = asyncio.get_event_loop()
try:
    loop.run_until_complete(main())
finally:
    loop.close()
```

### 4.2 事件循环的任务调度

事件循环维护一个任务队列，按照就绪顺序执行任务：

```python
async def task1():
    print("Task 1 start")
    await asyncio.sleep(1)
    print("Task 1 end")

async def task2():
    print("Task 2 start")
    await asyncio.sleep(0.5)
    print("Task 2 end")

async def main():
    await asyncio.gather(task1(), task2())

asyncio.run(main())
```

## 5. 任务（Task）和 Future

### 5.1 创建任务

任务是对协程的包装，用于并发执行：

```python
async def coro():
    await asyncio.sleep(1)
    return "result"

async def main():
    # 创建任务
    task = asyncio.create_task(coro())
    
    # 等待任务完成
    result = await task
    print(f"Result: {result}")

asyncio.run(main())
```

### 5.2 Future 对象

Future 代表一个异步操作的最终结果：

```python
async def set_future(fut):
    await asyncio.sleep(1)
    fut.set_result("Future completed")

async def main():
    loop = asyncio.get_running_loop()
    fut = loop.create_future()
    
    # 启动一个任务来设置 future 的结果
    asyncio.create_task(set_future(fut))
    
    # 等待 future 完成
    result = await fut
    print(f"Future result: {result}")

asyncio.run(main())
```

### 5.3 任务与 Future 的关系

- `Task` 是 `Future` 的子类
- 每个任务都是一个 future，但 future 不一定是任务
- 任务会自动调度协程执行

## 6. 并发执行多个协程

### 6.1 asyncio.gather()

等待多个协程完成，返回结果列表：

```python
async def fetch_url(url, delay):
    await asyncio.sleep(delay)
    return f"Response from {url}"

async def main():
    tasks = [
        fetch_url("http://example.com", 2),
        fetch_url("http://example.org", 1),
        fetch_url("http://example.net", 3),
    ]
    
    results = await asyncio.gather(*tasks)
    for result in results:
        print(result)

asyncio.run(main())
```

### 6.2 asyncio.wait()

更灵活地等待多个协程，可以设置超时和返回条件：

```python
async def worker(name, duration):
    print(f"{name} started")
    await asyncio.sleep(duration)
    print(f"{name} finished")
    return name

async def main():
    tasks = [
        asyncio.create_task(worker("A", 2)),
        asyncio.create_task(worker("B", 1)),
        asyncio.create_task(worker("C", 3)),
    ]
    
    # 等待所有任务完成
    done, pending = await asyncio.wait(tasks)
    for task in done:
        print(f"Completed: {task.result()}")
    
    # 等待第一个任务完成
    done, pending = await asyncio.wait(tasks, return_when=asyncio.FIRST_COMPLETED)
    print(f"First completed: {next(iter(done)).result()}")

asyncio.run(main())
```

### 6.3 asyncio.as_completed()

按完成顺序迭代协程：

```python
async def coro(i):
    await asyncio.sleep(i)
    return i

async def main():
    tasks = [coro(i) for i in range(3, 0, -1)]
    
    for future in asyncio.as_completed(tasks):
        result = await future
        print(f"Completed with result: {result}")

asyncio.run(main())
```

## 7. 高级用法

### 7.1 协程中的异常处理

```python
async def might_fail():
    await asyncio.sleep(1)
    raise ValueError("Something went wrong")

async def main():
    try:
        await might_fail()
    except ValueError as e:
        print(f"Caught error: {e}")
    
    # 在 gather 中处理异常
    tasks = [might_fail() for _ in range(3)]
    results = await asyncio.gather(*tasks, return_exceptions=True)
    for i, result in enumerate(results):
        if isinstance(result, Exception):
            print(f"Task {i} failed: {result}")
        else:
            print(f"Task {i} succeeded: {result}")

asyncio.run(main())
```

### 7.2 异步上下文管理器

```python
import asyncio

class AsyncConnection:
    async def __aenter__(self):
        print("Connecting...")
        await asyncio.sleep(0.5)
        print("Connected")
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        print("Disconnecting...")
        await asyncio.sleep(0.5)
        print("Disconnected")
    
    async def query(self):
        await asyncio.sleep(1)
        return "query result"

async def main():
    async with AsyncConnection() as conn:
        result = await conn.query()
        print(f"Result: {result}")

asyncio.run(main())
```

### 7.3 异步迭代器

```python
class AsyncCounter:
    def __init__(self, limit):
        self.limit = limit
        self.current = 0
    
    def __aiter__(self):
        return self
    
    async def __anext__(self):
        if self.current >= self.limit:
            raise StopAsyncIteration
        await asyncio.sleep(0.5)
        self.current += 1
        return self.current - 1

async def main():
    async for i in AsyncCounter(5):
        print(f"Count: {i}")

asyncio.run(main())
```

### 7.4 同步原语

#### 7.4.1 锁（Lock）

```python
import asyncio

async def worker(lock, name):
    async with lock:
        print(f"{name} acquired lock")
        await asyncio.sleep(1)
        print(f"{name} released lock")

async def main():
    lock = asyncio.Lock()
    await asyncio.gather(
        worker(lock, "A"),
        worker(lock, "B"),
        worker(lock, "C"),
    )

asyncio.run(main())
```

#### 7.4.2 信号量（Semaphore）

```python
async def worker(sem, name):
    async with sem:
        print(f"{name} entered")
        await asyncio.sleep(1)
        print(f"{name} exited")

async def main():
    sem = asyncio.Semaphore(2)  # 最多同时2个协程
    tasks = [worker(sem, f"Worker-{i}") for i in range(5)]
    await asyncio.gather(*tasks)

asyncio.run(main())
```

#### 7.4.3 事件（Event）

```python
async def waiter(event):
    print("Waiting for event...")
    await event.wait()
    print("Event received!")

async def setter(event):
    await asyncio.sleep(2)
    print("Setting event")
    event.set()

async def main():
    event = asyncio.Event()
    await asyncio.gather(waiter(event), setter(event))

asyncio.run(main())
```

#### 7.4.4 队列（Queue）

```python
async def producer(queue):
    for i in range(5):
        await asyncio.sleep(0.5)
        await queue.put(f"Item {i}")
        print(f"Produced: Item {i}")
    await queue.put(None)  # 终止信号

async def consumer(queue):
    while True:
        item = await queue.get()
        if item is None:
            break
        await asyncio.sleep(1)
        print(f"Consumed: {item}")
        queue.task_done()

async def main():
    queue = asyncio.Queue(maxsize=2)
    await asyncio.gather(
        producer(queue),
        consumer(queue),
    )

asyncio.run(main())
```

### 7.5 超时控制

```python
async def slow_operation():
    await asyncio.sleep(5)
    return "Done"

async def main():
    try:
        # 设置超时
        result = await asyncio.wait_for(slow_operation(), timeout=2)
        print(f"Result: {result}")
    except asyncio.TimeoutError:
        print("Operation timed out")
    
    # 使用 shield 防止取消
    try:
        result = await asyncio.wait_for(
            asyncio.shield(slow_operation()),
            timeout=2
        )
    except asyncio.TimeoutError:
        print("Timeout, but operation continues")
        await asyncio.sleep(3)  # 等待原操作完成

asyncio.run(main())
```

## 8. 实际应用示例

### 8.1 异步 HTTP 客户端

```python
import aiohttp
import asyncio

async def fetch(session, url):
    async with session.get(url) as response:
        return await response.text()

async def main():
    async with aiohttp.ClientSession() as session:
        urls = [
            "http://httpbin.org/get",
            "http://httpbin.org/ip",
            "http://httpbin.org/user-agent",
        ]
        
        tasks = [fetch(session, url) for url in urls]
        results = await asyncio.gather(*tasks)
        
        for url, content in zip(urls, results):
            print(f"{url}: {len(content)} bytes")

asyncio.run(main())
```

### 8.2 异步文件操作

```python
import aiofiles
import asyncio

async def write_file(filename, content):
    async with aiofiles.open(filename, 'w') as f:
        await f.write(content)

async def read_file(filename):
    async with aiofiles.open(filename, 'r') as f:
        return await f.read()

async def main():
    # 并发写入多个文件
    await asyncio.gather(
        write_file("file1.txt", "Hello from file 1"),
        write_file("file2.txt", "Hello from file 2"),
        write_file("file3.txt", "Hello from file 3"),
    )
    
    # 并发读取多个文件
    contents = await asyncio.gather(
        read_file("file1.txt"),
        read_file("file2.txt"),
        read_file("file3.txt"),
    )
    
    for i, content in enumerate(contents, 1):
        print(f"File {i}: {content}")

asyncio.run(main())
```

### 8.3 WebSocket 客户端

```python
import asyncio
import websockets

async def websocket_client():
    uri = "ws://localhost:8765"
    async with websockets.connect(uri) as websocket:
        await websocket.send("Hello Server!")
        response = await websocket.recv()
        print(f"Received: {response}")

async def main():
    await websocket_client()

asyncio.run(main())
```

### 8.4 数据库异步操作

```python
import asyncio
import asyncpg

async def db_example():
    # 连接数据库
    conn = await asyncpg.connect(
        user='user',
        password='password',
        database='database',
        host='localhost'
    )
    
    # 执行查询
    rows = await conn.fetch('SELECT * FROM users WHERE active = $1', True)
    for row in rows:
        print(f"User: {row['username']}")
    
    # 关闭连接
    await conn.close()

async def main():
    await db_example()

asyncio.run(main())
```

## 9. 调试和性能优化

### 9.1 调试协程

```python
import asyncio
import logging

logging.basicConfig(level=logging.DEBUG)

async def buggy_coro():
    await asyncio.sleep(1)
    raise RuntimeError("Oops!")

async def main():
    try:
        await buggy_coro()
    except Exception as e:
        print(f"Error: {e}")
    
    # 启用调试模式
    asyncio.run(main(), debug=True)

asyncio.run(main())
```

### 9.2 性能分析

```python
import asyncio
import time

async def task(i):
    await asyncio.sleep(0.1)
    return i * 2

async def main():
    start = time.time()
    
    # 顺序执行
    results = []
    for i in range(10):
        results.append(await task(i))
    print(f"Sequential: {time.time() - start:.2f}s")
    
    # 并发执行
    start = time.time()
    tasks = [task(i) for i in range(10)]
    results = await asyncio.gather(*tasks)
    print(f"Concurrent: {time.time() - start:.2f}s")

asyncio.run(main())
```

### 9.3 限制并发数

```python
import asyncio

async def limited_concurrent(tasks, limit):
    sem = asyncio.Semaphore(limit)
    
    async def worker(task):
        async with sem:
            return await task
    
    return await asyncio.gather(*[worker(t) for t in tasks])

async def main():
    async def slow_task(i):
        await asyncio.sleep(1)
        return i
    
    tasks = [slow_task(i) for i in range(10)]
    results = await limited_concurrent(tasks, 3)  # 最多3个并发
    print(f"Results: {results}")

asyncio.run(main())
```

## 10. 最佳实践

1. **避免阻塞操作**：不要在协程中使用同步阻塞操作（如 `time.sleep()`）
2. **合理控制并发数**：使用信号量限制并发，避免资源耗尽
3. **及时处理异常**：使用 `return_exceptions=True` 或单独处理每个任务的异常
4. **使用上下文管理器**：确保资源正确释放
5. **监控和日志**：记录协程的执行状态和性能指标
6. **测试异步代码**：使用 `pytest-asyncio` 进行测试

## 11. 常见问题

### 11.1 如何在协程中调用同步函数？

```python
import asyncio
from concurrent.futures import ThreadPoolExecutor

def blocking_io():
    # 模拟阻塞 I/O 操作
    import time
    time.sleep(2)
    return "Blocking IO result"

async def main():
    loop = asyncio.get_running_loop()
    
    # 在线程池中运行阻塞函数
    result = await loop.run_in_executor(None, blocking_io)
    print(f"Result: {result}")
    
    # 使用自定义线程池
    with ThreadPoolExecutor() as pool:
        result = await loop.run_in_executor(pool, blocking_io)
        print(f"Result with custom pool: {result}")

asyncio.run(main())
```

### 11.2 如何从同步代码调用协程？

```python
import asyncio

async def async_function():
    await asyncio.sleep(1)
    return "Async result"

# 在同步代码中运行协程
def sync_call():
    return asyncio.run(async_function())

# 在事件循环中运行
def sync_call_with_loop():
    loop = asyncio.new_event_loop()
    try:
        return loop.run_until_complete(async_function())
    finally:
        loop.close()

print(sync_call())
```

## 12. 总结

Python 协程通过 `async/await` 语法提供了强大的异步编程能力，特别适合 I/O 密集型应用。`asyncio` 库提供了完整的事件循环、任务调度和同步原语支持。掌握协程编程可以显著提升应用程序的性能和响应能力。

关键要点：
- 使用 `async def` 定义协程，`await` 等待异步操作
- 事件循环是协程调度的核心
- 任务（Task）用于并发执行协程
- 合理使用同步原语（锁、信号量、队列等）控制并发
- 遵循最佳实践，避免常见陷阱

通过本文的学习，你应该能够掌握 Python 协程的基础和高级用法，并在实际项目中应用异步编程技术。